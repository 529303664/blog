# JavaScript 中小数与整数的精度问题

> purpose:
> ①: 弄清楚 JavaScript 中小数精度问题(比如 0.1 + 0.2)
> ②: 弄清楚 JavaScript 的整数精度问题

### 十进制小数转为二进制小数方法

拿 173.8125 举例如何将之转化为二进制小数。

①. 针对整数部分 173，采取`除 2 取余，逆序排列`;

```js
173 / 2 = 86 ... 1
86 / 2 = 43 ... 0
43 / 2 = 21 ... 1   ↑
21 / 2 = 10 ... 1   | 逆序排列
10 / 2 = 5 ... 0    |
5 / 2 = 2 ... 1     |
2 / 2 = 1 ... 0
1 / 2 = 0 ... 1
```

得整数部分的二进制为 `10101101`。

②. 针对小数部分 0.8125，采用`乘 2 取整，顺序排列`;

```js
0.8125 * 2 = 1.625  |
0.625 * 2 = 1.25    | 顺序排列
0.25 * 2 = 0.5      |
0.5 * 2 = 1         ↓
```

得小数部分的二进制为 `1101`。

③. 将前面两部的结果相加，结果为 `10101101.1101`;

### 解析 0.1 + 0.2 的值为何不等于 0.3

根据上面的知识，将十进制小数 `0.1` 转为二进制：

```js
0.1 * 2 = 0.2
0.2 * 2 = 0.4 // 注意这里
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
0.2 * 2 = 0.4 // 注意这里，循环开始
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
...
```

可以发现有限十进制小数 `0.1` 却转化成了无限二进制小数 `0.000110011...`，可以看到精度在转化过程中丢失了！

能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 `0.1 ~ 0.9` 当中除了 `0.5` 之外的值在转化成二进制的过程中都丢失了精度。

另外在 JavaScript 中所有数值都以 IEEE-754 标准的 `64 bit` 双精度浮点数进行存储的。先来了解下 IEEE-754 标准下的[双精度浮点数](https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8)。

![](http://oqhtscus0.bkt.clouddn.com/dda7d5b38676abfa13afb344f8a792ed.jpg-300)

这幅图很关键，图中可以看到双精度浮点数由三部分组成，分别如下：

* sign(符号): 占 1 bit, 表示正负;
* exponent(指数): 占 11 bit;
* mantissa(尾数): 占 52 bit，表示精度;

另外推荐阅读 [JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)，我们可以了解到以下公式的由来：

![](http://oqhtscus0.bkt.clouddn.com/5c268e4bd6e0bf2466598d9d5cb58a16.jpg-200)

下面来实操一遍 `0.1 + 0.2` 的结果 `0.30000000000000004` 是怎么来的：

```js
0.1:
```



### 和自身相反数相等的数字

```js
4.5

4 / 2 = 2 ... 0
2 / 2 = 1 ... 0
1 / 2 = 0 ... 1

0.5 * 2 = 1

100.1
```

### 推荐文章

* [代码之谜系列](http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html)