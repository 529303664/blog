### 从一个疑问点开始

接上一章 [HOC 探索](https://github.com/MuYunyun/blog/blob/master/从0到1实现React/8.HOC探索.md#属性代理props-proxy) 抛出的问题 ———— react 中的 onChange 事件和原生 DOM 事件中的 onchange 表现不一致，举例说明如下：

```js
// React 中的 onChange 事件
class App extends Component {
  constructor(props) {
    super(props)
    this.onChange = this.onChange.bind(this)
  }

  onChange(e) {
    console.log('键盘松开立刻执行')
  }

  render() {
    return (
      <input onChange={this.onChange} />
    )
  }
}

// 原生 DOM 事件中的 onchange 事件：<input id='test'>
document.getElementById('test').addEventListener('change', (e) => {
  console.log('键盘松开以后还需按下回车键或者点下鼠标才会触发')
})
```

### 拨云见雾

我们来看下 React 最新的一个 issue [React Fire: Modernizing React DOM](https://github.com/facebook/react/issues/13525)。有两点信息和这篇文章的话题相关。

* Drastically simplify the event system
* Migrate from onChange to onInput and don’t polyfill it for uncontrolled components

从这两点内容我们可以得知下面的信息：

React 实现了一套[合成事件机制](https://reactjs.org/docs/events.html#event-pooling)，也就是它的事件机制和原生事件间会有不同。比如它目前 onChange 事件其实对应着原生事件中的 input 事件。在这个 issue 中明确了未来会使用 onInput 事件替代 onChange 事件，并且会大幅度地简化合成事件。

有了以上信息后，我们对 onChange 事件(将来的 onInput 事件)的代码作如下更改：

```js
function setAttribute(dom, attr, value) {
  ...
  if (attr.match(/on\w+/)) {        // 处理事件的属性:
    let eventName = attr.toLowerCase().substr(2)
    if (eventName === 'change') { eventName = 'input' } // 和现阶段的 react 统一
    dom.addEventListener(eventName, value)
  }
  ...
}
```

### 自由组件以及受控组件

区分自由组件以及受控组件在于表单的值是否由 `value` 这个属性控制，比较如下代码：

```js
const case1 = () => <input />                    // 此时输入框内可以随意增减任意值
const case2 = () => <input defaultValue={123} /> // 此时输入框内显示 123，能随意增减值
const case3 = () => <input value={123} />        // 此时输入框内显示 123，并且不能随意增减值
```

`case3` 的情形即为简化版的受控组件。

### 受控组件的实现

题目可以换个问法：当 `input` 的传入属性为 `value` 时(且没有 onChange 属性)，如何禁用用户的输入事件的同时又能获取焦点?

![](http://oqhtscus0.bkt.clouddn.com/0fa301946b3f4bf315d742735c333562.jpg-200)

首先想到了 html 自带属性 readonly、disable，它们都能禁止用户的输入，但是它们不能满足获取焦点这个条件。结合前文 `onChange` 的实现是监听 `input` 事件，若传入属性没有 `onChange` 事件，那么创造一个抹掉用户输入的 `input` 事件。代码实现如下：

```js
function setAttribute(dom, attr, value) {
  ...
  else if (attr.match(/on\w+/)) {        // 处理事件的属性:
    let eventName = attr.toLowerCase().substr(2)
    if (eventName === 'change') { eventName = 'input' } // 和现阶段的 react 统一
    dom.addEventListener(eventName, value)
  } else if (attr === 'value') {    // 受控组件逻辑
    dom.setAttribute(attr, value)
    const oldValue = dom.value
    dom.addEventListener('input', (e) => {
      dom.value = oldValue         // 关键语句
    })
  }
  ...
}
```

![](http://oqhtscus0.bkt.clouddn.com/353c8119b3c60a7f8f7696633c97ad28.jpg-200)

但是此时要是执行如下代码这样使用 `<input value={this.state.num} onChange={this.change} />` 就会发现新问题。观察上述代码逻辑，此时给 `input 标签` 绑定了两个 `input 监听事件`(先绑定的先执行)，这样会发生什么呢？

```js
class App extends Component {
  constructor() {
    super()
    this.state = { num: 123 }
    this.change = this.change.bind(this)
  }

  change(e) {
    console.log(e.target.value) // 会一直输出 123
    this.setState({
      num: e.target.value
    })
  }

  render() {
    return (
      <div>
        <input value={this.state.num} onChange={this.change} />
      </div>
    )
  }
}
```

由于此时先执行 `value 属性` 的 `input 事件`，致使执行 `onChange 属性` 的 `input 事件` 时，其传参的 `e.target.value` 仍然是 oldValue。

其实只要让 `onChange` 的 input 事件绑定优先于 `value` 的 input 事件绑定就行。

```js
function vdomToDom(vdom) {
  ...
  if (vdom.attributes
    && vdom.attributes.hasOwnProperty('onChange')
    && vdom.attributes.hasOwnProperty('value')) { // 受控组件，`onChange` 的 input 事件绑定优先于 `value` 的 input 事件绑定
      setAttribute(dom, 'onChange', vdom.attributes['onChange'])
      setAttribute(dom, 'value', vdom.attributes['value'])
      delete vdom.attributes['onChange']
      delete vdom.attributes['value']
    }
  for (const attr in vdom.attributes) {
    setAttribute(dom, attr, vdom.attributes[attr])
  }
  ...
}
```

// 未完待续