### 二刷高程

趁着十一的空闲，开始二刷高程。为了高效率的"刷"，尝试先刷目录。

> 目标：横扫脑子里空白的概念。

### 重载

JavaScript 没有函数重载，Java/C++ 中是有函数重载的(即相同函数名，但传的参数不同是当成不同函数的)

### label 语句的用法

区分以下两段函数：

```js
let num = 0
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    if (i === 5 && j === 5) {
      break
    }
    num++
  }
}
console.log(num) // 95
```

使用 label 语句：

```js
let num = 0
outPoint:
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    if (i === 5 && j === 5) {
      break outPoint
    }
    num++
  }
}
console.log(num) // 55
```

### 基本类型和引用类型

| 类型种类 | 访问类型 | 存储类型 |
|:---:|:---:|:---:|
| 基本类型 | 按值访问 | 栈内存 |
| 引用类型 | 按引用访问 | 堆内存 |

#### 函数参数是'按值传递'的

此处的按值传递和上面提到的按值访问是两个不一样的概念，此处指的是更改函数参数的引用是不会影响到原参数的。观察如下例子：

①.当传入参数为基本类型时：

```js
const count = 0

function add(num) {
  num = ++num
  return num
}

const result = add(count)

console.log(count)  // 0 可以看到传入参数仍然是 0 没有受到影响
console.log(result) // 1
```

②.当传入参数为引用类型时：

```js
const reference = { num: 0 }

function add(obj) {
  obj.num = 1
  obj = new Object() // ①
  obj.num = 2
  return obj
}

const result = add(reference)

console.log(reference) // { num: 1 }
console.log(result)    // { num: 2 }
```

注意 ① 处，此处函数参数的引用发生改变，后续对 obj 的操作对原参数不会产生影响。

### JavaScript 没有块级作用域